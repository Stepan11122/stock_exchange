import pygame
import sys
import math
import random
def draw_rotated_rect_hover(surface, x, y, theta_deg, x_r, y_t, mouse_pos,rd, color=(255, 255, 0), width_outline=2):
    theta = math.radians(-theta_deg)  # Clockwise rotation

    hw, hh = x / 2, y / 2

    # Define corners relative to center
    corners = [
        (-hw, -hh),
        ( hw, -hh),
        ( hw,  hh),
        (-hw,  hh),
    ]

    def rotate_point(px, py, angle):
        return (
            px * math.cos(angle) - py * math.sin(angle),
            px * math.sin(angle) + py * math.cos(angle)
        )

    rotated_corners = [rotate_point(px, py, theta) for px, py in corners]

    rightmost_x = max(rotated_corners, key=lambda p: p[0])[0]
    topmost_y = min(rotated_corners, key=lambda p: p[1])[1]

    cx = x_r - rightmost_x
    cy = y_t - topmost_y

    screen_points = [(cx + px, cy + py) for px, py in rotated_corners]

    # Check if mouse is inside the polygon
    def point_in_polygon(x, y, poly):
        inside = False
        n = len(poly)
        px, py = x, y
        for i in range(n):
            j = (i - 1) % n
            xi, yi = poly[i]
            xj, yj = poly[j]
            if ((yi > py) != (yj > py)):
                intersect = (px - xi) * (yj - yi) - (xj - xi) * (py - yi)
                if (intersect < 0) != (yj < yi):
                    inside = not inside
        return inside

    if point_in_polygon(mouse_pos[0], mouse_pos[1], screen_points) and rd:
        # Draw customized dashed outline
        really_draw=0
        for i in range(len(screen_points)):
            start = screen_points[i]
            end = screen_points[(i + 1) % len(screen_points)]
            draw_dashed_line(surface, color, start, end, dash_length=10, width=width_outline)
        return 0
    else:
        return 1

def draw_dashed_line(surface, color, start_pos, end_pos, dash_length=10, width=1):
    x1, y1 = start_pos
    x2, y2 = end_pos
    dl = dash_length

    length = math.hypot(x2 - x1, y2 - y1)
    dx = (x2 - x1) / length
    dy = (y2 - y1) / length

    for i in range(0, int(length / dl), 2):
        start_x = x1 + dx * dl * i
        start_y = y1 + dy * dl * i
        end_x = x1 + dx * dl * (i + 1)
        end_y = y1 + dy * dl * (i + 1)
        pygame.draw.line(surface, color, (start_x, start_y), (end_x, end_y), width)
# Настройки
Width, Height = 1540, 800
card_back_time=10
FPS = 60
pi=3.1415
AnimationToTalTime=60
AnimationOfRotationTime=0
BUTTON_COLOR_1 = (52, 152, 219)
BUTTON_HOVER_1 = (41, 128, 185)
TEXT_COLOR_1 = (255, 255, 255)
SHADOW_COLOR_1 = (0, 0, 0, 50)
button_width_1 = 180
button_height_1 = 50
card_height=300
card_wight=150
button_rect = pygame.Rect(Width - button_width_1 - 20, 20, button_width_1, button_height_1)
AnimationIsActive=0
# Инициализация Pygame
pygame.init()
font = pygame.font.SysFont("segoeui", 28)
screen = pygame.display.set_mode((Width, Height))
pygame.display.set_caption("Карточный стол - 4 игрока")
clock = pygame.time.Clock()
image = pygame.image.load("0background.png").convert_alpha()
dx_card=0
dy_card=0
PlayerMoved=0
scene=0
card_chosen=0
num_card_looking=-1
NumOfPlayers=4
CurrentPlayer=0
cards=[]
card_back=0
num_card_chosen=0
flip_duration=0
flip_time=15
# Основной цикл
running = True
for i in range(NumOfPlayers):
    deck=[]
    for k in range(10):
        deck.append(random.randint(1,21)-11)
    cards.append(deck)
while running:
    mouse_pos = pygame.mouse.get_pos()
    clock.tick(FPS)
    if AnimationIsActive:
        AnimationOfRotationTime+=1
    if AnimationOfRotationTime==AnimationToTalTime:
        AnimationOfRotationTime=0
        CurrentPlayer+=1
        AnimationIsActive=0
    if CurrentPlayer==NumOfPlayers:
        CurrentPlayer=0
    if not AnimationIsActive:
        current_card=0
        really_draw=1
        for elem in cards[CurrentPlayer]:
            if not PlayerMoved==1 or not current_card==num_card_chosen:
                dx,dy=0,0
                if current_card==num_card_chosen:
                      dx,dy=dx_card,dy_card
                images = pygame.image.load(str(elem)+".png").convert_alpha()
                imagesc = pygame.transform.scale(images, (card_wight/(1-dy/Height),card_height/(1-dy/Height)))
                ds=0
                if len(cards[CurrentPlayer])%2==0:
                    ds=2.5
                ss=0
                if (len(cards[CurrentPlayer])==9 or len(cards[CurrentPlayer])==10) and (current_card==0 or current_card==1 or current_card==8 or current_card==9):
                    ss=card_height/16
                    if current_card==0 or current_card==len(cards[CurrentPlayer])-1:
                        ss+=card_height/16     
                imager = pygame.transform.rotate(imagesc,-(-5*len(cards[CurrentPlayer])//2+5*current_card+ds+dx/20)/(1-1.75*dy/Height))
                screen.blit(imager,(Width/2-card_wight/2-5*len(cards[CurrentPlayer])//2/6*card_wight+5*current_card*card_wight/6+dx,2*Height/4+ss+dy))
            current_card+=1
        if not card_chosen:
            current_card=0
            num_card_looking=-1
            for elem in cards[CurrentPlayer]:
                if not PlayerMoved==1 or not len(cards[CurrentPlayer])-current_card-1==num_card_chosen:
                    ds=0
                    if len(cards[CurrentPlayer])%2==0:
                        ds=2.5
                    ss=0
                    if (len(cards[CurrentPlayer])==9 or len(cards[CurrentPlayer])==10) and (current_card==0 or current_card==1 or current_card==8 or current_card==9):
                        ss=card_height/16
                        if current_card==0 or current_card==len(cards[CurrentPlayer])-1:
                            ss+=card_height/16 
                    really_draw=draw_rotated_rect_hover(screen,card_wight,card_height,-(-5*len(cards[CurrentPlayer])//2+5*(len(cards[CurrentPlayer])-current_card-1)+ds),Width/2-card_wight/2-5*len(cards[CurrentPlayer])//2/6*card_wight+5*(len(cards[CurrentPlayer])-current_card-1)*card_wight/6+card_wight*math.cos(pi/180*(-5*len(cards[CurrentPlayer])//2+5*(len(cards[CurrentPlayer])-current_card-1)+ds))+card_height*abs(math.sin(pi/180*(-5*len(cards[CurrentPlayer])//2+5*(len(cards[CurrentPlayer])-current_card-1)+ds))),2*Height/4+ss, mouse_pos,really_draw)
                    if not really_draw:
                       num_card_looking=len(cards[CurrentPlayer])-current_card-1
                current_card+=1
    if AnimationIsActive:
        current_card=0
        if AnimationOfRotationTime<=AnimationToTalTime/2:
            AnimationOfRotationTime_1= AnimationOfRotationTime*2
            CurrentPlayer_1=CurrentPlayer
            forbidden_card=num_card_chosen
        else:
            AnimationOfRotationTime_1= (AnimationToTalTime-AnimationOfRotationTime)*2
            forbidden_card=-1
            if CurrentPlayer==NumOfPlayers-1:
               CurrentPlayer=-1
            CurrentPlayer_1=CurrentPlayer+1
        for elem in cards[CurrentPlayer_1]:
            if current_card!=forbidden_card:
                images = pygame.image.load(str(elem)+".png").convert_alpha()
                imagesc = pygame.transform.scale(images, (card_wight*(AnimationToTalTime+AnimationOfRotationTime_1/2)/AnimationToTalTime,card_height*(AnimationToTalTime+AnimationOfRotationTime_1/2)/AnimationToTalTime))
                ds=0
                if len(cards[CurrentPlayer_1])%2==0:
                    ds=2.5
                ss=0
                if (len(cards[CurrentPlayer_1])==9 or len(cards[CurrentPlayer_1])==10) and (current_card==0 or current_card==1 or current_card==8 or current_card==9):
                    ss=card_height/16
                    if current_card==0 or current_card==len(cards[CurrentPlayer_1])-1:
                        ss+=card_height/16     
                imager = pygame.transform.rotate(imagesc,-(-5*len(cards[CurrentPlayer_1])//2+5*current_card+ds))
                screen.blit(imager,(((Width/2-card_wight/2-5*len(cards[CurrentPlayer_1])//2/6*card_wight+5*current_card*card_wight/6)*(AnimationToTalTime-AnimationOfRotationTime_1)+Width/2*AnimationOfRotationTime_1)/AnimationToTalTime,((2*Height/4+ss)*(AnimationToTalTime-AnimationOfRotationTime_1)+(11*Height/10)*AnimationOfRotationTime_1)/AnimationToTalTime))
            current_card+=1        
    AngleOfScreenRotation=2*pi*(CurrentPlayer+(AnimationOfRotationTime/AnimationToTalTime))/NumOfPlayers
    
    image2 = pygame.transform.rotate(image, -360*(AnimationOfRotationTime+AnimationToTalTime*CurrentPlayer)/NumOfPlayers/AnimationToTalTime)
    image3 = pygame.transform.scale(image2,(4*Height,4*Height+abs(math.sin(2*AngleOfScreenRotation))*Height/2))
    is_hovered = button_rect.collidepoint(mouse_pos)
    # Обновляем экран
    pygame.display.flip()
    screen.blit(image3,(-2*Height+Width/2,-2.5*Height))
    # Draw shadow
    shadow_offset = 4
    shadow_rect = button_rect.move(shadow_offset, shadow_offset)
    pygame.draw.rect(screen, (0, 0, 0), shadow_rect, border_radius=12)

    # Draw button
    button_color = BUTTON_HOVER_1 if is_hovered else BUTTON_COLOR_1
    pygame.draw.rect(screen, button_color, button_rect, border_radius=12)

    # Draw text
    text = font.render("Next Player", True, TEXT_COLOR_1)
    text_rect = text.get_rect(center=button_rect.center)
    screen.blit(text, text_rect)
    if card_back:
        if abs(dx_card)>1 or abs(dy_card)>1:
            dx_card-=ddx_card
            dy_card-=ddy_card
        else:
            card_back=0
    
    if PlayerMoved:    
        if flip_duration<=flip_time//2:
            image2 = pygame.image.load(str(cards[CurrentPlayer][num_card_chosen])+".png").convert_alpha()
        else:
            image2= pygame.image.load("reverse.png").convert_alpha()
        image3 = pygame.transform.scale(image2,(abs((flip_w_start*(flip_time-flip_duration)-card_wight/2*flip_duration)/flip_time),(flip_h_start*(flip_time-flip_duration)+card_height/2*flip_duration)/flip_time))
        image4 = pygame.transform.rotate(image3,flip_theta_start*(flip_time-flip_duration)/flip_time)
        screen.blit(image4,((flip_x_start*(flip_time-flip_duration)+(Width/2-card_wight/4)*flip_duration)/flip_time,(flip_y_start*(flip_time-flip_duration)+Height/10*flip_duration)/flip_time))
        if flip_duration<flip_time:
            flip_duration+=1
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        if event.type == pygame.MOUSEBUTTONUP:
            if card_chosen==1:
                if dy_card>-Height/3:
                    card_back=1
                    ddx_card=dx_card/card_back_time
                    ddy_card=dy_card/card_back_time
                else:
                    ds=0
                    if len(cards[CurrentPlayer])%2==0:
                      ds=2.5
                    ss=0
                    if (len(cards[CurrentPlayer])==9 or len(cards[CurrentPlayer])==10) and (current_card==0 or current_card==1 or current_card==8 or current_card==9):
                      ss=card_height/16
                      if current_card==0 or current_card==len(cards[CurrentPlayer])-1:
                        ss+=card_height/16     
                    PlayerMoved=1
                    flip_x_start=Width/2-card_wight/2-5*len(cards[CurrentPlayer])//2/6*card_wight+5*num_card_chosen*card_wight/6+dx_card
                    flip_y_start=2*Height/4+ss+dy_card
                    flip_theta_start=-(-5*len(cards[CurrentPlayer])//2+5*num_card_chosen+ds+dx_card/20)/(1-1.75*dy_card/Height)
                    flip_w_start=card_wight/(1-dy_card/Height)
                    flip_h_start=card_height/(1-dy_card/Height)
            card_chosen=0
        if event.type == pygame.MOUSEBUTTONDOWN and num_card_looking!=-1 and not PlayerMoved:
            card_chosen=1
            num_card_chosen=num_card_looking
            x_start=mouse_pos[0]
            y_start=mouse_pos[1]
        if card_chosen and event.type == pygame.MOUSEMOTION:
            dx_card=mouse_pos[0]-x_start
            dy_card=mouse_pos[1]-y_start
        elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1 and not AnimationIsActive and PlayerMoved:
            if is_hovered:
                PlayerMoved=0
                dx_card=0
                dy_card=0
                AnimationIsActive=1
                flip_duration=0
pygame.quit()
sys.exit()
